# 학습키워드 정리

## 1. 목표

- 아래 질문에 대한 대답 정리하기
- 각 질문에 대한 느낀 점도 포함하기
  - 어디에 쓸 수 있을지
  - 어떤 특징이 이러이러한 것 같다 등

## 2. 질문 리스트

### 1. 비트연산자 보수이해하기

#### 1.1. 비트와 비트연산자

- bit란 binary digit로 컴퓨터에서 데이터의 가장 작은 단위이다. 0과 1을 사용하여 2진법으로 표현한다.
- 비트 연산자는 Bitwise operators라고 하며 비트를 조작하는 연산자를 지칭한다.
- 부호가 있는 정수는 가장 왼쪽 첫번째에 있는 최상위 비트로 음수를 표현한다. 0은 양수, 1은 음수를 나타낸다. 부호를 표현하는 비트를 제외한 나머지 비트로 정수의 값을 표현한다.

#### 1.2. 2진법의 음수 표현 - 2의 보수

- 구하려는 음수의 절대값의 2진 표현을 구한 후 이 숫자에 대해 1의 보수를 구한다. 1의 보수는 1은 0으로, 0은 1로 바꾸면 된다.
- 위의 결과에 1을 더한다.
  - 예를 들어 6비트로 -18을 표현해보자.
  - -18의 2진 표현을 구하기 위해 절대값 18의 2진 표현인 010010의 1의 보수를 구한다.
  - 010010의 1의 보수는 101101이다.
  - 101101에 1을 더한 101110이 -18의 6비트 정수 표현이다.

#### 1.3. 비트연산자

##### 1.3.1. 비트 NOT

- ~ a와 같이 틸데(~)를 사용하며, 피연산자의 1의 보수를 반환한다. 즉, 비트를 뒤집는다.
- ~ 010010 => 101101

##### 1.3.2. 비트 AND

- a & b 처럼 앰퍼샌드(&)를 사용하여 두 개의 피연산자를 취한다.
- 두 피연산자의 대응되는 비트가 모두 1이면 1을 반환하고, 아니면 0을 반환한다.
- 1010 & 1001 => 1000

##### 1.3.3. 비트 OR

- a | b 와 같이 파이프(|)을 사용하여 두 개의 피연산자를 취한다.
- 두 연산자의 대응되는 비트 중 하나라도 1이면 1을 반환하고, 아니면 0을 반환한다.
- 1010 | 1001 => 1011

##### 1.3.4. 비트 XOR

- a ^ b 와 같이 캐럿(^)을 사용하여 두 개의 피연산자를 취한다.
- 두 연산자의 대응되는 비트가 서로 다를때 1을 반환, 그 외에는 0을 반환.
- 1010 ^ 1001 => 0011

##### 1.3.5. 왼쪽 시프트

- a << b 와 같이 <<를 사용하여 두 개의 피연산자를 취한다.
- 좌항의 모든 비트를 우항의 숫자만큼 왼쪽으로 움직이고, 오른쪽은 0으로 채운다. 부호는 유지한다.
- 1010 << 2 => 101000

##### 1.3.6. 부호 있는 오른쪽 시프트

- a >> b 와 같이 >>를 사용하여 두 개의 피연산자를 취한다.
- 좌항의 모든 비트를 우항의 숫자만큼 오른쪽으로 움직이고, 부호는 유지한다. 왼쪽은 부호 비트로 채우고 오른쪽 남는 비트는 버린다.
- 11010 >> 2 => 11110

##### 1.3.7. 부호 없는 오른쪽 시프트

- a >>> b 와 같이 >>>를 사용하여 두 개의 피연산자를 취한다.
- 좌항의 모든 비트를 우항의 숫자만큼 오른쪽으로 움직이고, 왼쪽은 0으로 채운다. 오른쪽 남는 비트는 버린다.
- 11010 >>> 2 => 00110

#### 1.4. 느낀점

- 어디에 어떤 용도로 사용할 수 있는지는 잘 모르겠지만, 컴퓨터 내부에서 이루어지는 정수 연산 방법을 이해하게 된 것 같다.

### 2. 10을 2진 표현으로 변경하려면 어떤 순서로 계산해야 하는지 설명하기

#### 2.1. 설명

1. 10을 2로 나눠 몫과 나머지를 구한다.
2. 1에서 구한 나머지를 결과 배열에 unshift 한다.
3. 1에서 구한 몫으로 1, 2번을 반복한다.
4. 몫이 2보다 작을 때까지 반복한다.
5. 2보다 작아진 마지막 몫의 값을 결과 배열에 마지막으로 unshift 한다.
6. 결과 배열을 순서대로 출력한다.

#### 2.2. 느낀점

10진 표현을 2진 표현으로 변경하는 방법을 알게 됐고 코드로 구현하는 방법도 명확하게 알게 되었다. 알고리즘 문제로 나오면 금방 풀 수 있을 것 같다.

### 3. hoisting 에 대해서 설명하기

#### 3.1. 호이스팅이란?

- 자바스크립트에서 hoisting이란 변수와 함수의 선언이 그들이 포함된 scope의 최상단으로 끌어올려지는 것을 의미한다.
- scope는 전역(global) 또는 지역(local) 범위가 있으며 자바스크립트에서 local은 대부분의 경우 함수 범위를 말한다.

#### 3.2. 변수의 호이스팅

- 변수는 식별자의 선언만 호이스팅되기 때문에 값 할당 구문 이전에 변수에 접근하게 되면 var로 선언된 변수의 경우 undefined 값을 갖고 있다.
- let 또는 const로 선언된 변수 또한 호이스팅 되나, var와는 다르게 값 할당 구문 이전에 변수에 접근하게 되면 ReferenceError를 출력한다.

#### 3.3. 함수의 호이스팅

- 함수 선언식의 경우 함수 전체가 호이스팅되며, 함수 표현식은 변수 호이스팅과 마찬가지로 함수를 할당하려는 변수의 식별자만 호이스팅 된다.
- 위와 같은 이유로 함수 표현식으로 선언된 함수(특히 var)를 함수 할당 이전에 호출하게 되면 함수가 아니라는 TypeError가 출력된다.

#### 3.4. 결론

자바스크립트에서 변수와 함수가 호이스팅 되는 특징은 변수와 함수가 어디서 선언되든 상관없이 접근하고 사용할 수 있다는 장점도 있지만, 코드의 실행 결과를 예측하기 어렵게 하고 잠재적 오류의 가능성을 높인다는 단점도 있다. 그래서 함수 표현식을 포함한 변수는 최대한 선언과 초기화 후에 접근 및 사용하는 것이 좋다.

#### 3.5. 느낀점

자바스크립트에서의 변수와 함수의 내부 동작 방식을 어느정도 이해할 수 있게 되었고 왜 변수를 선언, 초기화 한 후 사용해야 하는지, 함수 선언식과 표현식의 차이가 무엇인지에 대해서도 알 수 있게 되었다. 이를 통해 잠재적 오류를 좀 더 쉽게 잡아낼 수 있을 것 같다.

