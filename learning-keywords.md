# 학습키워드 정리

## 1. 목표

- 아래 질문에 대한 대답 정리하기
- 각 질문에 대한 느낀 점도 포함하기
  - 어디에 쓸 수 있을지
  - 어떤 특징이 이러이러한 것 같다 등

## 2. 질문 리스트

### 1. 비트연산자 보수이해하기

#### 1.1. 비트와 비트연산자

- bit란 binary digit로 컴퓨터에서 데이터의 가장 작은 단위이다. 0과 1을 사용하여 2진법으로 표현한다.
- 비트 연산자는 Bitwise operators라고 하며 비트를 조작하는 연산자를 지칭한다.
- 부호가 있는 정수는 가장 왼쪽 첫번째에 있는 최상위 비트로 음수를 표현한다. 0은 양수, 1은 음수를 나타낸다. 부호를 표현하는 비트를 제외한 나머지 비트로 정수의 값을 표현한다.

#### 1.2. 2진법의 음수 표현 - 2의 보수

- 구하려는 음수의 절대값의 2진 표현을 구한 후 이 숫자에 대해 1의 보수를 구한다. 1의 보수는 1은 0으로, 0은 1로 바꾸면 된다.
- 위의 결과에 1을 더한다.
  - 예를 들어 6비트로 -18을 표현해보자.
  - -18의 2진 표현을 구하기 위해 절대값 18의 2진 표현인 010010의 1의 보수를 구한다.
  - 010010의 1의 보수는 101101이다.
  - 101101에 1을 더한 101110이 -18의 6비트 정수 표현이다.

#### 1.3. 비트연산자

##### 1.3.1. 비트 NOT

- ~ a와 같이 틸데(~)를 사용하며, 피연산자의 1의 보수를 반환한다. 즉, 비트를 뒤집는다.
- ~ 010010 => 101101

##### 1.3.2. 비트 AND

- a & b 처럼 앰퍼샌드(&)를 사용하여 두 개의 피연산자를 취한다.
- 두 피연산자의 대응되는 비트가 모두 1이면 1을 반환하고, 아니면 0을 반환한다.
- 1010 & 1001 => 1000

##### 1.3.3. 비트 OR

- a | b 와 같이 파이프(|)을 사용하여 두 개의 피연산자를 취한다.
- 두 연산자의 대응되는 비트 중 하나라도 1이면 1을 반환하고, 아니면 0을 반환한다.
- 1010 | 1001 => 1011

##### 1.3.4. 비트 XOR

- a ^ b 와 같이 캐럿(^)을 사용하여 두 개의 피연산자를 취한다.
- 두 연산자의 대응되는 비트가 서로 다를때 1을 반환, 그 외에는 0을 반환.
- 1010 ^ 1001 => 0011

##### 1.3.5. 왼쪽 시프트

- a << b 와 같이 <<를 사용하여 두 개의 피연산자를 취한다.
- 좌항의 모든 비트를 우항의 숫자만큼 왼쪽으로 움직이고, 오른쪽은 0으로 채운다. 부호는 유지한다.
- 1010 << 2 => 101000

##### 1.3.6. 부호 있는 오른쪽 시프트

- a >> b 와 같이 >>를 사용하여 두 개의 피연산자를 취한다.
- 좌항의 모든 비트를 우항의 숫자만큼 오른쪽으로 움직이고, 부호는 유지한다. 왼쪽은 부호 비트로 채우고 오른쪽 남는 비트는 버린다.
- 11010 >> 2 => 11110

##### 1.3.7. 부호 없는 오른쪽 시프트

- a >>> b 와 같이 >>>를 사용하여 두 개의 피연산자를 취한다.
- 좌항의 모든 비트를 우항의 숫자만큼 오른쪽으로 움직이고, 왼쪽은 0으로 채운다. 오른쪽 남는 비트는 버린다.
- 11010 >>> 2 => 00110

#### 1.4. 느낀점

- 어디에 어떤 용도로 사용할 수 있는지는 잘 모르겠지만, 컴퓨터 내부에서 이루어지는 정수 연산 방법을 이해하게 된 것 같다.

### 2. 10을 2진 표현으로 변경하려면 어떤 순서로 계산해야 하는지 설명하기

#### 2.1. 설명

1. 10을 2로 나눠 몫과 나머지를 구한다.
2. 1에서 구한 나머지를 결과 배열에 unshift 한다.
3. 1에서 구한 몫으로 1, 2번을 반복한다.
4. 몫이 2보다 작을 때까지 반복한다.
5. 2보다 작아진 마지막 몫의 값을 결과 배열에 마지막으로 unshift 한다.
6. 결과 배열을 순서대로 출력한다.

#### 2.2. 느낀점

10진 표현을 2진 표현으로 변경하는 방법을 알게 됐고 코드로 구현하는 방법도 명확하게 알게 되었다. 알고리즘 문제로 나오면 금방 풀 수 있을 것 같다.

