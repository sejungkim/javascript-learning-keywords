# 학습키워드 정리

## 1. 목표

- 아래 질문에 대한 대답 정리하기
- 각 질문에 대한 느낀 점도 포함하기
  - 어디에 쓸 수 있을지
  - 어떤 특징이 이러이러한 것 같다 등

## 2. 질문 리스트

### 1. 비트연산자 보수이해하기

#### 1.1. 비트와 비트연산자

- bit란 binary digit로 컴퓨터에서 데이터의 가장 작은 단위이다. 0과 1을 사용하여 2진법으로 표현한다.
- 비트 연산자는 Bitwise operators라고 하며 비트를 조작하는 연산자를 지칭한다.
- 부호가 있는 정수는 가장 왼쪽 첫번째에 있는 최상위 비트로 음수를 표현한다. 0은 양수, 1은 음수를 나타낸다. 부호를 표현하는 비트를 제외한 나머지 비트로 정수의 값을 표현한다.

#### 1.2. 2진법의 음수 표현 - 2의 보수

- 구하려는 음수의 절대값의 2진 표현을 구한 후 이 숫자에 대해 1의 보수를 구한다. 1의 보수는 1은 0으로, 0은 1로 바꾸면 된다.
- 위의 결과에 1을 더한다.
  - 예를 들어 6비트로 -18을 표현해보자.
  - -18의 2진 표현을 구하기 위해 절대값 18의 2진 표현인 010010의 1의 보수를 구한다.
  - 010010의 1의 보수는 101101이다.
  - 101101에 1을 더한 101110이 -18의 6비트 정수 표현이다.

#### 1.3. 비트연산자

##### 1.3.1. 비트 NOT

- ~ a와 같이 틸데(~)를 사용하며, 피연산자의 1의 보수를 반환한다. 즉, 비트를 뒤집는다.
- ~ 010010 => 101101

##### 1.3.2. 비트 AND

- a & b 처럼 앰퍼샌드(&)를 사용하여 두 개의 피연산자를 취한다.
- 두 피연산자의 대응되는 비트가 모두 1이면 1을 반환하고, 아니면 0을 반환한다.
- 1010 & 1001 => 1000

##### 1.3.3. 비트 OR

- a | b 와 같이 파이프(|)을 사용하여 두 개의 피연산자를 취한다.
- 두 연산자의 대응되는 비트 중 하나라도 1이면 1을 반환하고, 아니면 0을 반환한다.
- 1010 | 1001 => 1011

##### 1.3.4. 비트 XOR

- a ^ b 와 같이 캐럿(^)을 사용하여 두 개의 피연산자를 취한다.
- 두 연산자의 대응되는 비트가 서로 다를때 1을 반환, 그 외에는 0을 반환.
- 1010 ^ 1001 => 0011

##### 1.3.5. 왼쪽 시프트

- a << b 와 같이 <<를 사용하여 두 개의 피연산자를 취한다.
- 좌항의 모든 비트를 우항의 숫자만큼 왼쪽으로 움직이고, 오른쪽은 0으로 채운다. 부호는 유지한다.
- 1010 << 2 => 101000

##### 1.3.6. 부호 있는 오른쪽 시프트

- a >> b 와 같이 >>를 사용하여 두 개의 피연산자를 취한다.
- 좌항의 모든 비트를 우항의 숫자만큼 오른쪽으로 움직이고, 부호는 유지한다. 왼쪽은 부호 비트로 채우고 오른쪽 남는 비트는 버린다.
- 11010 >> 2 => 11110

##### 1.3.7. 부호 없는 오른쪽 시프트

- a >>> b 와 같이 >>>를 사용하여 두 개의 피연산자를 취한다.
- 좌항의 모든 비트를 우항의 숫자만큼 오른쪽으로 움직이고, 왼쪽은 0으로 채운다. 오른쪽 남는 비트는 버린다.
- 11010 >>> 2 => 00110

#### 1.4. 느낀점

- 어디에 어떤 용도로 사용할 수 있는지는 잘 모르겠지만, 컴퓨터 내부에서 이루어지는 정수 연산 방법을 이해하게 된 것 같다.

---------

### 2. 10을 2진 표현으로 변경하려면 어떤 순서로 계산해야 하는지 설명하기

#### 2.1. 설명

1. 10을 2로 나눠 몫과 나머지를 구한다.
2. 1에서 구한 나머지를 결과 배열에 unshift 한다.
3. 1에서 구한 몫으로 1, 2번을 반복한다.
4. 몫이 2보다 작을 때까지 반복한다.
5. 2보다 작아진 마지막 몫의 값을 결과 배열에 마지막으로 unshift 한다.
6. 결과 배열을 순서대로 출력한다.

#### 2.2. 느낀점

10진 표현을 2진 표현으로 변경하는 방법을 알게 됐고 코드로 구현하는 방법도 명확하게 알게 되었다. 알고리즘 문제로 나오면 금방 풀 수 있을 것 같다.

----------

### 3. hoisting 에 대해서 설명하기

#### 3.1. 호이스팅이란?

- 자바스크립트에서 hoisting이란 변수와 함수의 선언이 그들이 포함된 scope의 최상단으로 끌어올려지는 것을 의미한다.
- scope는 전역(global) 또는 지역(local) 범위가 있으며 자바스크립트에서 local은 대부분의 경우 함수 범위를 말한다.

#### 3.2. 변수의 호이스팅

- 변수는 식별자의 선언만 호이스팅되기 때문에 값 할당 구문 이전에 변수에 접근하게 되면 var로 선언된 변수의 경우 undefined 값을 갖고 있다.
- let 또는 const로 선언된 변수 또한 호이스팅 되나, var와는 다르게 값 할당 구문 이전에 변수에 접근하게 되면 ReferenceError를 출력한다.

#### 3.3. 함수의 호이스팅

- 함수 선언식의 경우 함수 전체가 호이스팅되며, 함수 표현식은 변수 호이스팅과 마찬가지로 함수를 할당하려는 변수의 식별자만 호이스팅 된다.
- 위와 같은 이유로 함수 표현식으로 선언된 함수(특히 var)를 함수 할당 이전에 호출하게 되면 함수가 아니라는 TypeError가 출력된다.

#### 3.4. 결론

자바스크립트에서 변수와 함수가 호이스팅 되는 특징은 변수와 함수가 어디서 선언되든 상관없이 접근하고 사용할 수 있다는 장점도 있지만, 코드의 실행 결과를 예측하기 어렵게 하고 잠재적 오류의 가능성을 높인다는 단점도 있다. 그래서 함수 표현식을 포함한 변수는 최대한 선언과 초기화 후에 접근 및 사용하는 것이 좋다.

#### 3.5. 느낀점

자바스크립트에서의 변수와 함수의 내부 동작 방식을 어느정도 이해할 수 있게 되었고 왜 변수를 선언, 초기화 한 후 사용해야 하는지, 함수 선언식과 표현식의 차이가 무엇인지에 대해서도 알 수 있게 되었다. 이를 통해 잠재적 오류를 좀 더 쉽게 잡아낼 수 있을 것 같다.

----------

### 4. !! 은 무엇을 의미하는가? 어떻게 활용할 수 있을까?

#### 4.1. 설명

- !!(double exclamation)은 논리연산자 NOT(!)을 두 번 쓴 것으로, boolean type이 아닌 값을 boolean type으로 바꿔주는 효과가 있다.
- Boolean data type이란 true 또는 false의 두 가지 값만 갖는 데이터 타입이다.
- 어떤 값에 논리연산자 NOT을 적용하면 그 값의 반대되는 boolean 값을 얻을 수 있지만, !를 두 번 적용하게 되면 한 번 더 NOT이 되므로 원래 값의 boolean 값을 얻을 수 있는 것이다.
  - !5 === false
  - !!5 === true
- 즉, !!value는 Boolean(value)와 같은 효과가 있다.
  - !!5 === Boolean(5)

#### 4.2. 느낀점

!은 자주 썼었지만 !!은 사실 처음 봤는데 어떤 값의 boolean 값을 얻고 싶을 때 편리하게 사용할 수 있을 것 같다.

----------

### 5. 3개 이상의 switch 문을 어떻게 3항 연산자로 대체할 수 있을까? 코드로 예시를 들라.

#### 5.1. 설명

삼항 연산자는 conditional operator 또는 ternary operator라고 하는데, 자바스크립트의 연산자 중 유일하게 3개의 피연산자를 갖는다. 

다음과 같은 3개 이상의 case를 갖는 switch 문이 있다고 하자.

```javascript
const value = 4;

switch (value) {
  case 1:
    console.log('one');
    break;
  case 2:
    console.log('two');
    break;
  case 3:
    console.log('three');
    break;
  default:
    console.log('nothing');
}
```

value 값에 따라 다른 결과를 출력하는 간단한 예제인데, 이 코드를 삼항 연산자로 바꾸어 똑같이 동작하도록 만들 수 있다. 삼항 연산자로 바꾼 코드는 아래와 같다.

```javascript
const value = 4;

value === 1 ? console.log('one')
: value === 2 ? console.log('two')
: value === 3 ? console.log('three')
: console.log('nothing');
```

3가지 case일 때 뿐만 아니라 그 이상의 case가 있어도 위와 같이 삼항 연산자를 이용하여 코드를 작성할 수 있다.

#### 5.2. 느낀점

2개의 케이스가 있을 때만 삼항 연산자를 사용했었는데 3개 이상의 케이스에서도 삼항 연산자를 사용할 수 있다는 걸 새로 알게 됐다. 또, if-else 문 뿐만 아니라 switch 문도 삼항 연산자로 바꿔 쓸 수 있음을 알 수 있었다. 코드 작성 중 적합한 경우에 삼항 연산자를 잘 이용하면 더욱 간결한 코드를 작성할 수 있을 것 같다.

----------

### 6. ==와 ===의 차이는 정확히 무엇인가?

#### 6.1. 설명

- `==`는 Double equals로 느슨한 같음(abstract comparison)을 비교한다. `==`는 비교하려는 두 값이 type이 다르면 비교 가능한 같은 type으로 강제 형 변환을 한 후 엄격한 비교를 한다.
- `===`는 Triple equals로 엄격한 같음(strict comparison)을 비교한다. `===`는 비교하려는 두 값의 type과 value가 모두 같을 때 true를 반환한다.

#### 6.2. 기억할만한 예외들

##### 6.2.1. ==를 사용할 때

- 0과 ''(빈 문자열)은 false와 같다.
  - `0 == false` 
  - `'' == false`
- null과 undefined는 서로 같지만 다른 것들과는 같지 않다.
  - `null == undefined`
- NaN은 자기 자신인 NaN을 포함하여 그 어떤 것과도 같지 않다.
- Infinity는 true처럼 사용되지만 true나 false와 비교할 수 없다.
- 빈 배열 []은 true처럼 사용되지만 0, '', false와 비교하면 같다.
  - `[] == 0`
  - `[] == ''`
  - `[] == false`

##### 6.2.2. ===를 사용할 때

- NaN은 자기 자신인 NaN과도 비교할 수 없다.

#### 6.3. 느낀점

 ==이 값을 비교하기 전에 강제로 형 변환을 한다는 사실을 새로 알게 되었고 ==에 예측하기 어려운 예외상황이 많다는 것도 알게 되었다. 웬만하면 ===을 쓰라는 말만 들었지 왜 그런지 정확히 이해하지 못했는데 이번에 알아보면서 이유를 체감하게 된 것 같다. 앞으로 최대한 ===만 쓸 수 있도록 하고, 어쩔 수 없이 ==을 사용해야 하는 상황이 오면 결과를 확실히 확인한 후 사용해야겠다.

 ----------

### 7. const value = a || b; 코드의 의미는 무엇인가?

#### 7.1. 설명

- `||` 은 Logical OR라고 하며 논리연산자 중 하나로, 비교하는 두 개의 피연산자 중 하나만 true여도 true를 반환하고 모두 false이면 false를 반환한다.
- `const value = a || b;` 는 위와 같은 원리를 이용하여 변수 초기값을 할당하는 방법이다. a와 b가 boolean 타입의 변수라면 원래 작동 방식대로 true나 false를 반환하겠지만, boolean이 아닌 평가할 수 있는 다른 타입의 값이라면 다음과 같이 작동한다.
  - true로 평가할 수 있는 값이 있다면 true로 평가할 수 있는 첫 번째 값을 반환한다.
    - `undefined || 1` 은 1을 반환
    - `true || 2` 는 true을 반환
  - 모든 값이 false로 평가된다면 가장 마지막 값을 반환한다.
    - `null || 0` 은 0을 반환
- a와 b의 자리에는 변수뿐만 아니라 함수나 수식과 같은 표현도 쓸 수 있고, 반환 값을 통해 같은 방식으로 평가된다. 또한 객체는 항상 true로 평가된다.
  - `(x = 0) || (x = 1)` 는 `x = 1` 의 결과인 1을 반환
- 논리연산자는 결과를 확정 지을 수 있을 때 평가를 멈추고 결과를 바로 반환하는 '단축 평가(Short-circuit evaluation)'를 수행한다.
  - `||` 은 피연산자 중 하나만 true여도 평가 결과가 true이기 때문에, 왼쪽부터 평가를 시작해서 true로 평가되는 피연산자를 만나면 더이상 진행하지 않고 true로 평가를 종료한다.
  - `true || (x = 1)` 는 첫 번째 인자가 true이기 때문에 다음 인자인 `x = 1` 을 수행하지 않고 바로 true를 반환한다. 따라서 변수 x에는 1이 할당되지 않는다.

#### 7.2. 느낀점

논리연산자 `||`은 종종 사용하던 것이었는데 좀 더 명확하게 작동 방식을 알게 되었고, 단축 평가를 수행하여 생각보다 효율적으로 동작하고 있다는걸 알게 되었다. 사용하려는 어떤 값의 단순한 유효성 검사와 할당에 유용할 것 같고 간단한 if 문을 대신해서 더욱 간결하게 사용 할 수 있을 것 같다.

----------

